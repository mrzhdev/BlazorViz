@inject IJSRuntime JSRuntime
@inject NavigationManager NavManager
@using Microsoft.JSInterop

<div>
    <strong>@Title</strong>

    <p class="title">Visualization  for CSLY with Viz.js </p>
   
    
    <div>

        <label for="grammarFile" class="input-label">Importer un fichier grammaire</label>
        <InputFile id="grammarFile" OnChange="LoadGrammar"/>
        <label for="inputFile" class="input-label">Importer un fichier source</label>
        <InputFile id="inputFile" OnChange="LoadGrammar"/>
        <div class="input" style="display: flex; flex-direction: row">
            
            <textarea style="flex-grow: 1" id="grammarBox" maxlength="2000" spellcheck="false" @bind="grammar" />
            @* <StandaloneCodeEditor @ref="_grammar" Id="grammarBox" ConstructionOptions="GrammarConstructionOptions"/> *@
            
            <textarea style="flex-grow: 1" i d="inputBox" maxlength="2000" spellcheck="false" @bind="source" />
            @* <StandaloneCodeEditor @ref="_source" Id="inputBox" ConstructionOptions="InputConstructionOptions"/> *@
        </div>
        <button id="submitButton" @onclick="Render">
            Render
        </button>
    </div>
    

    <div id="graph" >
        <div id="output">
            <div id="error"></div>
          </div>
    </div>
</div>

@code {

    // Demonstrates how a parent component can supply parameters
    [Parameter]
    public string? Title { get; set; }

    string source = @"

while i < 10 do
(
   i := i + 1;
   print ""hello""
)";

    string grammar = @"

genericLexer WhileLexer;

[String] STRING;
[Int] INT;
[AlphaId] ID; 


[ KeyWord] IF:""if"";
[ KeyWord] THEN:""then"";
[ KeyWord] ELSE:""else"";
[ KeyWord] WHILE:""while"";
[ KeyWord] DO:""do"";
[ KeyWord] SKIP:""skip"";
[ KeyWord] TRUE:""true"";
[ KeyWord] FALSE:""false"";
[ KeyWord] NOT:""not"";
[ KeyWord] AND:""and"";
[ KeyWord] OR:""or"";
[ KeyWord] PRINT:""print"";

 [Sugar] GREATER : "">"";

[Sugar] LESSER : ""<"";

[Sugar] EQUALS : ""=="";

[Sugar] DIFFERENT : ""!="";

[Sugar] CONCAT : ""."";

[Sugar] ASSIGN : "":="";

[Sugar] PLUS : ""+"";
[Sugar] MINUS : ""-"";
[Sugar] TIMES : ""*"";
[Sugar] DIVIDE : ""/"";

[Sugar] LPAREN : ""("";
[Sugar] RPAREN : "")"";
[Sugar] SEMICOLON : "";"";

parser WhileParser;


[Right 50] LESSER;
[Right 50] GREATER;
[Right 50] EQUALS;
[Right 50]DIFFERENT;

[Right 10] CONCAT;
       
[Right 10] PLUS;
[Left 10] MINUS;
[Right 50] TIMES;
[Left 50]DIVIDE;

[Prefix 100] MINUS;

[Right 10] OR;
[Right 50] AND;
[Prefix 100] NOT;


-> statement :  LPAREN statement RPAREN ;


statement : sequence;


[Operand] operand : [INT | TRUE | FALSE | STRING | ID];
[Operand] operand : LPAREN WhileParser_expressions RPAREN;

sequence : [statementIf | statementWhile | statementAssign | statementSkip | statementPrint] additionalStatements*;

additionalStatements : SEMICOLON [statementIf | statementWhile | statementAssign | statementSkip | statementPrint];

statementIf: IF WhileParser_expressions THEN statement ELSE statement;

statementWhile: WHILE WhileParser_expressions DO statement;

statementAssign: ID ASSIGN WhileParser_expressions;

statementSkip: SKIP;

statementPrint: PRINT WhileParser_expressions;

";

    private string dot;

    protected override async void OnInitialized()
    {
    }

// private StandaloneCodeEditor _grammar;
// private StandaloneCodeEditor _source;



    private async Task LoadGrammar(InputFileChangeEventArgs e)
    {
        
        var content = 
            await new StreamReader(e.File.OpenReadStream()).ReadToEndAsync();
        grammar = content;
        //_grammar.SetValue(grammar);
    }
    
    private async  Task LoadSource(InputFileChangeEventArgs e)
    {
        var content = 
            await new StreamReader(e.File.OpenReadStream()).ReadToEndAsync();
        source = content;
        //_source.SetValue(source);
    }

    // private StandaloneEditorConstructionOptions GrammarConstructionOptions(StandaloneCodeEditor editor)
    // {
    //     
    //     return new StandaloneEditorConstructionOptions
    //     {
    //         AutomaticLayout = true,
    //         Value = grammar
    //     };
    // }
    
    // private StandaloneEditorConstructionOptions InputConstructionOptions(StandaloneCodeEditor editor)
    // {
    //     return new StandaloneEditorConstructionOptions
    //     {
    //         AutomaticLayout = true,
    //         Value = source
    //     };
    // }
    
    private async void Render()
    {

        // grammar = await _grammar.GetValue();
        // source = await _source.GetValue();
        
        var dotresult = CslyProcessor.GetDot(grammar, source);
        if (dotresult.IsOK)
        {
            dot = dotresult.Result;
            await VizRender(dot);
        }
        else
        {
            foreach (var error in dotresult.Errors)
            {
                AppendError(error);
            }
        }
    }

    public async Task VizRender(string graph) 
    {
        await JSRuntime.InvokeAsync<string>("vizRender",graph);     
    }

    public async Task AppendError(string errorMessage) 
    {
        await JSRuntime.InvokeAsync<string>("appendError", errorMessage);     
    }
}
